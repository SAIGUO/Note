[TOC]

# 第二章 面试基础知识

## 一、C++

### 1.1、对空类求sizeof，结果？

答案：1。

空类虽然不包含任何信息，但在创建该类型的实例时它必须在内存中占一定空间，否则无法使用，VS中每个空类实例占1字节。

### 1.2、如果空类中有构造与析构函数，求sizeof？

答案：1。

调用构造、析构函数只需知道地址，函数地址与类型有关，与实例无关，不需要额外内存。

### 1.3、如果将析构改为虚函数，求sizeof？

答案：4/8 。

有虚函数会为该类型生成虚函数表，每个类型的实例会有一个指向该虚函数表的指针，32位机器上指针占4字节，64位机器上占8字节。

### 1.4、拷贝构造函数/复制构造函数的调用

调用时间：

- 函数参数为类的对象时
- 函数的返回值为类的对象时
- 对象通过另一个对象进行初始化时

> 拷贝构造函数的第一个参数必须是自身类类型的引用。
>
> 因为拷贝构造函数被用来初始化非引用类类型参数，如果其参数不是引用类型，拷贝构造函数将会继续调用拷贝构造函数，形成无休止的递归调用导致栈溢出，VS、GCC中会编译报错。
>
> 具体参考：<https://blog.csdn.net/hackbuteer1/article/details/6545882>

### 1.5、定义一个赋值运算符函数

注意：

- 定义赋值运算符函数时要将返回值类型声明为该类型的引用，函数结束前返回实例自身的引用（*this），实现连续赋值
- 传入参数类型应声明为常量引用，原因同1.4，并加上const
- 在分配新内存前释放实例自身已有的内存，避免内存泄漏
- 判断传入参数与当前实例是否相同，相同则不赋值直接返回，否则释放了当前实例的内存后，传入参数的内存也被释放了，无法进行赋值

> 更安全的方式是先创建一个临时实例，再交换临时实例与原来的实例。

### 1.6、C++和C#中struct与class的不同

C++：struct默认访问权限是public；class默认private

C#：struct、class默认都是private，但struct是值类型，实例在栈上分配内存；class定义的是引用类型，实例在堆上分配内存

## 二、数据结构

### 2.1、字符串

合并两个数组（包括字符串）等需要较多重复移动操作的问题，可以考虑**从后往前**处理，减少移动次数。

同样一个常量字符串，赋值给两个不同的字符数组中，得到两个不同的字符数组；赋值给两个指针，得到两个指向同一个地址的指针。

### 2.2、链表

递归本质上是栈结构，但当递归调用层次较深时可能会导致函数调用栈溢出，这个时候用栈的代码鲁棒性好一些。

## 三、算法和数据操作

### 3.1、查找和排序

华为面试排序算法：

对较小范围内的较多的数据进行排序，数据有重复，可使用辅助空间，要保证稳定性。（桶排序）

> 遇到这类排序算法，要向面试官问清楚具体使用场景及条件约束。

有序数组翻转问题：

二分法查找有序数组翻转位置，对特殊情况，前中后三位置元素相等，要改用顺序查找。

### 3.2、递归和循环

需要重复多次计算相同的问题，可以选择递归或者循环。

通常递归实现的代码较简单，但消耗时间及空间，可能导致栈溢出。

### 3.3、位运算

常见面试问题：

- 1、判断二进制中1的个数。

解法一：

将输入整数最后一位与1做与运算，判断最后一位是否为1，然后将整数右移一位再判断，直至整数为0。尽量用位运算而不是除法，因为位运算计算速度快。

缺点：当整数为负数时，首位符号位为1，一直做右移最后会得到0XFFFFFFFF，陷入死循环。

解法二：

代替移动输入整数，选择左移1。先将整数与1做与运算，再将1左移一位与整数做与运算，直至左移至跟整数长度相同。

缺点：移动次数较多，整数有多少位就要移动多少次。

解法三：

先将整数减1，将最右边的1到后面的所有位的值改变，再与原整数做与运算，将整数最右边的1变为0，即，原整数中有多少1就做多少次运算。

- 2、判断一个整数是否是2的整数次幂。

如果是，那改整数的二进制表示中有且仅有一位是1。将改整数减1与原整数做与运算应为0。

- 3、已知两个整数m、n，需要改变m二进制的 多少位才能得到n。

先对两个数做异或运算，为1的位即为两个整数不同的位，计算异或结果中1的位数。
