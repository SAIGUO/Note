[TOC]

# 第三章 高质量的代码

## 一、代码的完整性

### 1.1、求n次幂

当计算一个数a的n次幂时，代替连乘n次的做法，我们可以使用已有结果快速相乘。当n为偶数时，a^n = a^(n/2)*a^(n/2)；当n为奇数时，a^n = a^((n-1/2))*a^((n-1)/2))*a。利用递归计算最终的结果。

### 1.2、大数的表达

当要表达一个大数的时候，用int、long long会有溢出问题，最容易的方法是用字符串或者数组表达。

### 1.3、删除链表中某个结点

解法一：

遍历链表，删除与给定结点相同的结点。O(n)

解法二：

间接删除：用下一个结点内容覆盖被删除结点内容，删除下一个结点。O(1)

> 覆盖的时候注意：
>
> 如果链表只有一个结点，要删除头（尾）结点时，先将结点删除，再将头结点设为null。
>
> 如果链表有多个结点，要删除尾结点时，先遍历链表，再删除。

>  解法二基于要删除的结点存在于链表中，如果要做这个判断需要O(n)的时间，为了得到O(1)时间复杂度，我们将这个判断放在delete调用里面。

### 1.4、调整数组顺序使奇数位于偶数前

解法一：

遍历数组，每遇到一个偶数，将后面的数依次前移，将该偶数放在数组最后。O(n^2)

解法二：

双指针，一个指向数组开始，一个直接数组结尾，当首指针遇到偶数、尾指针遇到奇数且首指针位于尾指针前时交换两个指针内容。

> 奇数表达：n%2 != 0（不要用n%2 == 1）或者 n & 0x1 != 0

解法三：

数组分类标准可以替换为其他，如是否是负数，是否是3的倍数等，为了保证分类标准改变后最大可能的复用代码，这里将分类标准的框架抽象出来，用一个单独的函数判断，并通过函数指针调用对应的函数。

## 二、代码鲁棒性

鲁棒性也叫健壮性，指程序可以判断输入是否合乎规范，对不符合要求的输入进行合理的处理。提高鲁棒性的有效途径是进行防御性编程，即预见在什么地方可能出现问题，对这些可能出现的问题制定处理方式。

最常用的防御性编程是在函数入口验证用户输入是否符合要求，如判断输入指针是否为空，字符串是否为空等。

### 2.1、链表倒数第k个结点

使用双指针，第一个指针先走k-1步，第二个指针再从头开始一起走，第一个指针走到链表末端的时候，第二个指针正好指向倒数第k个结点。

> 注意：
>
> - 判断输入链表指针是否为空
> - 判断k是否小于1
> - 判断k是否大于链表长

### 2.2、求链表的中间结点

如果链表结点数为奇数，返回中间结点；如果为偶数，返回中间两个结点中的任意一个。

也可以用快慢两个指针解决，都从头结点开始，一个指针一次走一步，另一个一次走两步，当快指针走到链表末尾时，走得慢的指针刚好走到链表中间。

### 2.3、判断单向链表是否形成环

同样使用快慢指针，如果走的快的指针追上了走的慢的指针，说明链表中有环。

### 2.4、反转链表

首先对指针进行非空判断，或者只有一个结点时的处理。

需要三个指针i, j, k分别指向前，中，后三个连着的结点。初始状态下j指向第一个结点，循环过程中先用k记录j的下一个结点，再修改j的next指针，将i指针移动到j，j移动到k，直至j为空指针，最终i指针指向反转后的链表初始结点。

### 2.5、合并有序链表

首先对空链表进行处理。

合并过程可以用递归或者循环，要注意的是指针使用过后要后移。

### 2.6、判断树B是否是树A的子结构

首先对输入的树指针进行判断处理。

先递归遍历A，找与B根节点相同的结点。再递归判断A中由该结点开始的子树是否与B相同。

