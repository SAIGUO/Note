[TOC]

# 第三章 高质量的代码

## 一、代码的完整性

#### 面试题16：数值的整数次方

注意一些特殊情况，如输入指数小于1时，或者底数为0，指数为负的情况。

更高效的方法：

当计算一个数a的n次幂时，代替连乘n次的做法，我们可以使用已有结果快速相乘。当n为偶数时，a^n = a^(n/2)*a^(n/2)；当n为奇数时，a^n = a^((n-1/2))*a^((n-1)/2))*a。利用递归计算最终的结果。

#### 面试题17：打印从1到最大的n位数

- 解法一：

如果n较小，可以直接计算出最大的n位数m，遍历输出1~m。

但这里没有规定n的范围，当n很大时，用int或者long long都会溢出，因此这里要用字符串模拟数字的加法。

字符串中每个字符都在'0'~'9'之间，数字最大为n位，因此可以使用一个长度n+1的字符串，最后一位为‘\0’，当数字不为n位时，前半部分补0。首先将每一位数字初始化为‘0’，每次为字符串加1，打印。这个过程主要包括两部分：用字符串中的数字模拟加法运算；把字符串表示的数字打印出来。

> 在对字符串执行加法计算时，为了找到停止递增的时间，每次递增后都要与n位的'99..99'做一次比较，相等时停止递增，时间复杂度O(n)。
>
> 这里可以通过字符串第一个字符是否产生进位来判断是否为最大的n位数。

- 解法二：

全排列。从1到最大n位的数其实就是n个从0~9的全排列，只不过打印的时候前面的0不打印。

全排列可以用递归表示，数字的每一位用0~9的一位表达，然后设置下一位，递归结束条件为最后一位设置完。

>  当要表达一个大数的时候，用int、long long会有溢出问题，最容易的方法是用字符串或者数组表达。

#### 面试题18_1：在O(1)时间内删除链表结点

- 解法一：

遍历链表，删除与给定结点相同的结点。O(n)

- 解法二：

间接删除：用下一个结点内容覆盖被删除结点内容，删除下一个结点。O(1)

> 覆盖的时候注意：
>
> 如果链表只有一个结点，要删除头（尾）结点时，先将结点删除，再将头结点设为null。
>
> 如果链表有多个结点，要删除尾结点时，先遍历链表，再删除。

>  解法二基于要删除的结点存在于链表中，如果要做这个判断需要O(n)的时间，为了得到O(1)时间复杂度，我们将这个判断放在delete调用里面。

#### 面试题18_2：删除有序链表中的重复结点

- 解法一：

空链表或者只有一个结点的链表直接返回。

首先定义一个空的前指针pre，从头开始遍历链表，如果有两个结点值相同，那么将与该值相等的连续结点全部删除，如果pre为空，将pre指向重复点之后的第一个结点，如果不为空，将pre的next指针指向这个结点。

- 解法二：

先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况。设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。

#### 面试题19：正则表达式

判断一个字符串是否与给定的正则表达式匹配。

逐字符匹配。首先区分模式中第二个字符是否是"\*"，如果不是，只需要比对字符串第一个字符与模式第一个字符是否相同，相同则都向后移一位继续比较，如果遇到不同直接返回false。模式中第二个字符是"\*"时，如果字符串与模式第一个字符相同，字符串向后移动一个字符，模式可以保持不变或者向后移动两个字符，字符串也可以直接用第一个字符与模式向后移动两个字符后比较。

#### 面试题20：表示数值的字符串

扫描字符串的时候要考虑到不同的数值结构。总的来说，表示数值的字符串应遵循模式A\[.\[B]][e|EC\]或者\.B\[e|EC]。A、C有符号整数，B为无符号整数。

#### 面试题21：调整数组顺序使奇数位于偶数前

- 解法一：

遍历数组，每遇到一个偶数，将后面的数依次前移，将该偶数放在数组最后。O(n^2)

- 解法二：

双指针，一个指向数组开始，一个直接数组结尾，当首指针遇到偶数、尾指针遇到奇数且首指针位于尾指针前时交换两个指针内容。

> 奇数表达：n%2 != 0（不要用n%2 == 1）或者 n & 0x1 != 0

- 解法三：

数组分类标准可以替换为其他，如是否是负数，是否是3的倍数等，为了保证分类标准改变后最大可能的复用代码，这里将分类标准的框架抽象出来，用一个单独的函数判断，并通过函数指针调用对应的函数。

## 二、代码鲁棒性

鲁棒性也叫健壮性，指程序可以判断输入是否合乎规范，对不符合要求的输入进行合理的处理。提高鲁棒性的有效途径是进行防御性编程，即预见在什么地方可能出现问题，对这些可能出现的问题制定处理方式。

最常用的防御性编程是在函数入口验证用户输入是否符合要求，如判断输入指针是否为空，字符串是否为空等。

#### 面试题22：链表倒数第k个结点

使用双指针，第一个指针先走k-1步，第二个指针再从头开始一起走，第一个指针走到链表末端的时候，第二个指针正好指向倒数第k个结点。

> 注意：
>
> - 判断输入链表指针是否为空
> - 判断k是否小于1
> - 判断k是否大于链表长

#### 相关题目：求链表的中间结点

如果链表结点数为奇数，返回中间结点；如果为偶数，返回中间两个结点中的任意一个。

也可以用快慢两个指针解决，都从头结点开始，一个指针一次走一步，另一个一次走两步，当快指针走到链表末尾时，走得慢的指针刚好走到链表中间。

#### 面试题23：链表中环的入口结点

第一步：判断链表是否形成环

同样使用快慢指针，如果走的快的指针追上了走的慢的指针，说明链表中有环。

第二步：找到环的入口

定义两个指针，如果链表中的环有n个结点，一个指针先走n步，然后两个指针以相同速度前进，相遇结点即为环的入口。因为当第二个指针指向环的入口时，第一个指针已经围绕环走了一圈又到了入口处。

> 环中结点的数目：
>
> 判断是否有环时，如果快慢指针相遇了，说明存在环，指针相遇的结点一定在环中，因此可以从相遇结点出发一边走一边计数，当再次到达这个结点时就可以得到环中结点树。

### 2.4、反转链表

首先对指针进行非空判断，或者只有一个结点时的处理。

需要三个指针i, j, k分别指向前，中，后三个连着的结点。初始状态下j指向第一个结点，循环过程中先用k记录j的下一个结点，再修改j的next指针，将i指针移动到j，j移动到k，直至j为空指针，最终i指针指向反转后的链表初始结点。

### 2.5、合并有序链表

首先对空链表进行处理。

合并过程可以用递归或者循环，要注意的是指针使用过后要后移。

### 2.6、判断树B是否是树A的子结构

首先对输入的树指针进行判断处理。

先递归遍历A，找与B根节点相同的结点。再递归判断A中由该结点开始的子树是否与B相同。

