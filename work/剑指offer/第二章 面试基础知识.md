[TOC]

# 第二章 面试基础知识

## 一、C++

### 1.1、对空类求sizeof，结果？

答案：1。

空类虽然不包含任何信息，但在创建该类型的实例时它必须在内存中占一定空间，否则无法使用，VS中每个空类实例占1字节。

### 1.2、如果空类中有构造与析构函数，求sizeof？

答案：1。

调用构造、析构函数只需知道地址，函数地址与类型有关，与实例无关，不需要额外内存。

### 1.3、如果将析构改为虚函数，求sizeof？

答案：4/8 。

有虚函数会为该类型生成虚函数表，每个类型的实例会有一个指向该虚函数表的指针，32位机器上指针占4字节，64位机器上占8字节。

### 1.4、拷贝构造函数/复制构造函数的调用

调用时间：

- 函数参数为类的对象时
- 函数的返回值为类的对象时
- 对象通过另一个对象进行初始化时

> 拷贝构造函数的第一个参数必须是自身类类型的引用。
>
> 因为拷贝构造函数被用来初始化非引用类类型参数，如果其参数不是引用类型，拷贝构造函数将会继续调用拷贝构造函数，形成无休止的递归调用导致栈溢出，VS、GCC中会编译报错。
>
> 具体参考：<https://blog.csdn.net/hackbuteer1/article/details/6545882>

### 1.5、定义一个赋值运算符函数

注意：

- 定义赋值运算符函数时要将返回值类型声明为该类型的引用，函数结束前返回实例自身的引用（*this），实现连续赋值
- 传入参数类型应声明为常量引用，原因同1.4，并加上const
- 在分配新内存前释放实例自身已有的内存，避免内存泄漏
- 判断传入参数与当前实例是否相同，相同则不赋值直接返回，否则释放了当前实例的内存后，传入参数的内存也被释放了，无法进行赋值

> 更安全的方式是先创建一个临时实例，再交换临时实例与原来的实例。

### 1.6、C++和C#中struct与class的不同

C++：struct默认访问权限是public；class默认private

C#：struct、class默认都是private，但struct是值类型，实例在栈上分配内存；class定义的是引用类型，实例在堆上分配内存

## 二、数据结构

### 2.1、数组

数据名也是一个指针，指向数组第一个元素。

#### 面试题3_1：找出给定数组中的重复数字

长度为n的数组中每个数字在0~n-1。

- 解法一：

哈希表，扫描数组，判断哈希表中是否已经包含该数字。时间复杂度O(n)，空间复杂度O(n)。

- 解法二：

扫描重排。数组中n个数在0~n-1范围内，如果没有重复数字，排序后应该满足数字i在第i个下标的位置。扫描时，先将下标i与该位置数字m比较，如果相等则扫描下一个，如果不同，比较m与下标为m处的数字，如果相等说明m重复，如果不同，则交换位置，继续扫描。时间复杂度O(n)，空间复杂度O(1)。

#### 面试题3_2：找出数组中重复数字的变形

长度为n+1的数组中每个数字在1~n之间。要求：不改变原始数组。

数组长度为n+1，但每个数字范围在1~n，则肯定会有数字重复。不改变原始数组需要额外的O(n)空间。

将数组从中间数字分为两部分，1~m、m+1~n，如果1~m之间数字数目超过m，说明这部分一定有重复数字，继续对这部分数字划分直到找到重复的数字。

### 2.2、字符串

合并两个数组（包括字符串）等需要较多重复移动操作的问题，可以考虑**从后往前**处理，减少移动次数。

同样一个常量字符串，赋值给两个不同的字符数组中，得到两个不同的字符数组；赋值给两个指针，得到两个指向同一个地址的指针。

#### 面试题5：将字符串中的空格替换为%20

考虑从后向前替换，减少移动操作。

先遍历一遍字符串，统计空格数量，计算替换后的字符串长度，从后向前开始字符的复制与替换。

### 2.3、链表

#### 面试题6：从尾到头打印链表

链表遍历顺序为从头到尾，打印顺序为从尾到头，可以考虑用栈实现这种后进先出的问题。

也可以用递归来实现，每次先输出结点后面的结点的值再输出该结点自身的值。

递归本质上是栈结构，但当递归调用层次较深时可能会导致函数调用栈溢出，这个时候用栈的代码鲁棒性好一些。

### 2.4、树

#### 面试题7：重建二叉树

根据二叉树的先序与中序遍历结果重建二叉树。（不含重复数字）

先找出先序第一个结点即为根节点，再在中序遍历结果中找到该结点，区分出左右子树数据，然后递归的去建立左右子树。

#### 面试题8：二叉树的下一个结点

分三种情况考虑：

如果该结点有右子树，则下一个为右子树的最左子结点；

如果没有右子树，但是是该结点父结点的左孩子，则下一个结点为它的父结点；

如果还不是父结点的左孩子，则继续向父节点的父节点查找，直到找到一个结点，它是它的父结点的左子结点，这个结点的父结点即为下一个结点，如果直到根节点仍然找不到这样的结点，那下一个结点为空。

### 2.5、栈和队列

#### 面试题9：用两个栈实现队列

有两个栈stack1，stack2，stack1存新入栈的数据，stack2存要删除的数据。stack2中最上面的数据刚好是stack1中最下面的数据，也是最早入栈的数据，正好满足队列先进先出的要求。每次新数据进入要先放进stack1，弹出时，如果stack2有数据就要先弹出stack2的，如果stack2为空时再将stack1中的数据放入stack2后依次弹出。

#### 面试题9变形：用两个队列实现栈

假设有两个队列queue1，queue2，要实现栈的功能，即后进先出，需要将先进队列的数据挪到后进来的数据后面。

假设现在queue1中只有一个数据a，如果现在进来一个数据b，为了让b在a的前面，可以先把a放入queue2，将b放入queue1中后再将a放回queue1，这时候b在a的前面。如果进来c，先把a,b放入queue2，再在queue1中放入c后将a,b放回queue1，这样弹出的顺序与队列相同。

或者也可以在进入数据时直接放入queue1，如果需要弹出时再将最后进来的数据以外的全部数据放入queue2，删除最后的数据后再放回queue1。

## 三、算法和数据操作

### 3.1、递归和循环

需要重复多次计算相同的问题，可以选择递归或者循环。

通常递归实现的代码较简单，但消耗时间及空间，可能导致栈溢出。

#### 面试题10：斐波那契数列

- 解法一：

递归，代码简单，但会有很多重复计算，效率较低。

- 解法二：

动态规划，记录下前面每步的计算结果，下次可以直接使用。

### 3.2、查找和排序

华为面试排序算法：

对较小范围内的较多的数据进行排序，数据有重复，可使用辅助空间，要保证稳定性。（桶排序）

> 遇到这类排序算法，要向面试官问清楚具体使用场景及条件约束。

有序数组翻转问题：

二分法查找有序数组翻转位置，对特殊情况，前中后三位置元素相等，要改用顺序查找。

#### 面试题11：旋转数组的最小数字

一个原始有序递增的数组，从最开始的若干个元素被放到数组的末尾，行程旋转数组，找出旋转数组的旋转位置。

- 解法一：

遍历，找到第一个最小的元素。O(n)。

- 解法二：

二分查找，用前中后三个指针，对比三个数据，如果中间数据小于第一个数据，则旋转位置位于前半部分，否则位于后半部分。但是对于一种特殊情况：数组中有重复数据，如{0,1,1,1,1}，两种反转结果{1,0,1,1,1}、{1,1,1,0,1}，初始获取的三个数据都是1，这个时候反转位置的0可能位于前半部分也可能位于后半部分，二分查找将失效，需要使用顺序查找。

### 3.3、回溯法

回溯法类似做枚举，本质上是在做递归，回溯的路径可以看成是一个栈。

#### 面试题12：矩阵中的路径

判断一个矩阵中是否存在一条包含某个字符串所有字符的路径。

当定位了路径中前n个字符的位置后，在第n个字符周围的格子没有找到第n+1个字符时，就回到路径第n-1个字符继续查找。

#### 面试题13：机器人运动范围

与上一题的不同在于，求字符串路径的时候，如果不能继续往下走，回溯的时候，当前的位置也会被设置为未使用，但本题是计算运动范围，只要能到达某个位置，即使回溯也仍然可以计入可达范围的数量。

### 3.4、动态规划与贪婪算法

求一个问题的最优解时，如果该问题可以划分成更小的子问题，子问题间还有重叠的更小的子问题，子问题也存在最优解，可以考虑动态规划。

#### 面试题14：剪绳子

给一段长度为n的绳子，剪成m段，使得每段绳子之积最大。

- 解法一：

动态规划。时间O(n^2)，空间O(n)。

- 解法二：

贪婪算法。O(1)。

尽量多的剪成长度为3的小段。

具体参考：https://www.jianshu.com/p/65b39734430c

### 3.5、位运算

常见面试问题：

#### 面试题15：判断二进制中1的个数

- 解法一：

将输入整数最后一位与1做与运算，判断最后一位是否为1，然后将整数右移一位再判断，直至整数为0。尽量用位运算而不是除法，因为位运算计算速度快。

缺点：当整数为负数时，首位符号位为1，一直做右移最后会得到0XFFFFFFFF，陷入死循环。

- 解法二：

代替移动输入整数，选择左移1。先将整数与1做与运算，再将1左移一位与整数做与运算，直至左移至跟整数长度相同。

缺点：移动次数较多，整数有多少位就要移动多少次。

- 解法三：

先将整数减1，将最右边的1到后面的所有位的值改变，再与原整数做与运算，将整数最右边的1变为0，即，原整数中有多少1就做多少次运算。

#### 相关题目1：判断一个整数是否是2的整数次幂

如果是，那改整数的二进制表示中有且仅有一位是1。将改整数减1与原整数做与运算应为0。

#### 相关题目2：已知两个整数m、n，需要改变m二进制的 多少位才能得到n

先对两个数做异或运算，为1的位即为两个整数不同的位，计算异或结果中1的位数。

