[TOC]

# 第四章 解决问题的思路

## 一、画图让抽象问题形象化

#### 面试题27：二叉树的镜像

用递归依次交换每个非叶子结点的左右子结点。对输入二叉树指针判断，如果是空指针或者无左右子结点，直接返回。

或者利用栈循环遍历每个结点。

#### 面试题28：对称的二叉树

如果一棵二叉树和它的镜像是一样的，说明它是对称的。

镜像二叉树的左右子结点顺序与原二叉树相反，它的先序遍历跟对称先序遍历结果应该是一样的。但如果不是对称二叉树，但结点值相同，两种遍历方式得到的结果应该也是一样的，因此，该方法要存储遇到的空指针。

也可以递归比对左右子树，左结点的左子树与右结点的右子树对比，左结点的右子树与右结点的左子树对比。

#### 面试题29：顺时针打印矩阵

该题重点在于循环条件的设定。多层循环时，每条边循环条件的边界位置，满足条件等。重点考虑一行或者一列矩阵会出现的问题，避免重复打印。

## 二、举例让抽象问题具体化

#### 面试题30：包含min函数的栈

该题目有两个要求：1、加入、弹出数据需满足栈的结构；2、在O(1)时间内可以得到目前栈的最小元素。

要满足第一个条件，数据的加入与删除需是在一个正常的栈结构里面；而在此条件下若要满足第二个条件就必须再用一个辅助栈，与第一个栈对应的位置，存储到该位置为止最小的元素。这样，辅助栈栈顶存的应该是整个栈的最小元素，如果弹出栈顶元素后，辅助栈也要弹出栈顶元素，如果加入新的元素，要重新计算栈内最小值，压入辅助栈栈顶。

#### 面试题31：栈的压入、弹出序列

根据一个入栈序列，判断另一个序列是否为该栈的出栈序列。

首先，需要建立一个辅助栈，用来依次压入入栈序列中的数字。

- 解法一：

从出栈序列入手。判断出栈序列的规律：如果下一个弹出的数字刚好是栈顶数字，就直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。

- 解法二：

从入栈序列入手。将入栈序列的数据依次压入辅助栈，每次压入数据后对比栈顶元素是否是下一个待弹出数据，如果是则弹出栈顶元素，弹出数据位置后移；如果不是则继续将入栈序列中的数据压入栈中。如果最后入栈序列数据都进了辅助栈，而最终的辅助栈为空，说明可以按照出栈序列的顺序出栈。

#### 面试题32_1：不分行从上到下打印二叉树

层次遍历，广度优先，考虑使用队列。

> 取栈顶元素用top()；取队首元素用front()。

#### 面试题32_2：分行从上到下打印二叉树

- 解法一：

分行需要知道每行结点数量，这里可以用两个临时变量，一个记录当前层次结点总数n，另一个用来记录push进来的下一层结点数m，当前层次结点打印完后，将下一层结点数m赋值给n，m重置为0。

- 解法二：

也可以只用一个变量，初始非空树只放了根节点在队列，此时这一层结点数为1，当打印1个并pop出一个结点后，队列里面存的应该都是根节点下一层全部n个结点，因此再打印n个数据后换行。

#### 面试题32_3：之字形打印二叉树

分析可知：之字形顺序打印二叉树需要两个栈，当打印奇数层时，需要将先保存左子节点，再保存右子结点到第一个栈里；打印偶数层时，先保存右子结点再保存左子结点到第二个栈里。之所以需要两个栈是因为，每次要把一层结点打印完才打印下一层，而打印过程中又需要有序存储下一层结点，栈的结构特点是后进先出，如果只用一个栈将会变成深度优先的遍历。

#### 面试题33：二叉搜索树的后序遍历序列

判断给出的数组是否可以是某棵搜索二叉树的后序遍历序列。

后序遍历总是把根结点放在后面，根结点前的数据应该能分成两个连续的部分，一部分的值都小于根结点，另一部分都大于根结点的值。根据这个性质可以递归判断给出数组是否满足要求。

#### 面试题34：二叉树中和为某一值的路径

路径是从根结点出发到叶子结点，也就是说是以根结点为起点，只有先序遍历是先访问根结点。

当用先序遍历访问某一结点时，我们先把该结点添加到路径上，并累计当前路径的值，如果该结点为叶子结点，并且路径中结点的和等于目标值，说明当前路径满足要求。如果不是叶子结点，则递归访问它的子结点。如果访问到了叶子结点仍然不满足需要可以回到它的父结点。因此，递归函数结束前需要将路径上当前结点删除并减去当前结点的值。这个过程可以用栈来表示，但这里我们用vector实现一个栈来保存路径，通过push_back在路径末尾添加结点，通过pop_back在末尾删除结点。不用栈是因为stack中只能得到栈顶元素，而我们需要路径上所有结点，且能够方便找到父结点。

## 三、分解让复杂问题简单化

#### 面试题35：复杂链表的复制

- 解法一：

先遍历一遍，复制链表中的每个结点，并用next指针连接起来。再去找到每个原始链表中结点的pSibling指针指向的结点位置，在新链表中找到对应结点的位置与结点连接。时间复杂度O(n^2)。

- 解法二：

第一步仍然是复制链表并连接。复制的同时将原始链表上的结点N与新链表上对应的结点N‘配对信息放入一个哈希表，在设置新链表上的pSibling指针时，可以通过找到N指向的pSibling指针指向的S结点来找到S’。时间复杂度O(n)，空间复杂度O(n)。

- 解法三：

step1：创建每个结点N对应的结点N‘，将N’街道N的后面；

step2：如果原始结点N的pSibling指向S，它的复制结点N‘的pSibling指向S’；

step3：拆分链表，奇数位置连接起来为原始链表，偶数位置连接起来为复制后的链表。 

> 第一步注意，新的结点要new出来，不要直接用原node赋值；
>
> 第三步注意，最后剩余两个结点时，要把他们之间的连接段开，与前面的分开处理。

#### 面试题36：二叉搜索树与双向链表

将一个二叉搜索树转为一个排序的双向链表，不能创建新节点，只能调整指针方向。

二叉搜索树的中序遍历结果刚好是全部数据的排序结果，因此可以根据中序遍历结果，将结点左指针指向前一个数据，右指针指向下一个数据。根据中序遍历特征可知，当遍历到一个根结点时，它的左子树已经遍历完毕，形成一个有序的链表了，且最大值就是链表中最后一个结点值，将根结点左指针指向这个值。再将根结点与右子树中最小的值连接，右子树最小值就是右子树中序遍历结果的第一个结点。这个过程可以用递归表示。需要注意的是，我们需要一个指向已经排序的链表的尾结点的指针，用来与当前结点连接。

#### 面试题37：序列化二叉树

实现两个函数，分别用来序列化与反序列化二叉树。

可以根据前序遍历顺序来序列化二叉树，即从根结点开始，反序列化也可以从根结点开始。遍历时如果碰到nullptr指针，就序列化为一个特殊字符（如“$”），结点数值之间用特殊字符（如“，”）隔开。