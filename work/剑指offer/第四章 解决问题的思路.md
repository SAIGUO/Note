[TOC]

# 第四章 解决问题的思路

## 一、画图让抽象问题形象化

#### 面试题27：二叉树的镜像

用递归依次交换每个非叶子结点的左右子结点。对输入二叉树指针判断，如果是空指针或者无左右子结点，直接返回。

或者利用栈循环遍历每个结点。

#### 面试题28：对称的二叉树

如果一棵二叉树和它的镜像是一样的，说明它是对称的。

镜像二叉树的左右子结点顺序与原二叉树相反，它的先序遍历跟对称先序遍历结果应该是一样的。但如果不是对称二叉树，但结点值相同，两种遍历方式得到的结果应该也是一样的，因此，该方法要存储遇到的空指针。

也可以递归比对左右子树，左结点的左子树与右结点的右子树对比，左结点的右子树与右结点的左子树对比。

#### 面试题29：顺时针打印矩阵

该题重点在于循环条件的设定。多层循环时，每条边循环条件的边界位置，满足条件等。重点考虑一行或者一列矩阵会出现的问题，避免重复打印。

### 二、举例让抽象问题具体化

#### 面试题30：包含min函数的栈

该题目有两个要求：1、加入、弹出数据需满足栈的结构；2、在O(1)时间内可以得到目前栈的最小元素。

要满足第一个条件，数据的加入与删除需是在一个正常的栈结构里面；而在此条件下若要满足第二个条件就必须再用一个辅助栈，与第一个栈对应的位置，存储到该位置为止最小的元素。这样，辅助栈栈顶存的应该是整个栈的最小元素，如果弹出栈顶元素后，辅助栈也要弹出栈顶元素，如果加入新的元素，要重新计算栈内最小值，压入辅助栈栈顶。

#### 面试题31：栈的压入、弹出序列

根据一个入栈序列，判断另一个序列是否为该栈的出栈序列。

首先，需要建立一个辅助栈，用来依次压入入栈序列中的数字。

- 解法一：

从出栈序列入手。判断出栈序列的规律：如果下一个弹出的数字刚好是栈顶数字，就直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。

- 解法二：

从入栈序列入手。将入栈序列的数据依次压入辅助栈，每次压入数据后对比栈顶元素是否是下一个待弹出数据，如果是则弹出栈顶元素，弹出数据位置后移；如果不是则继续将入栈序列中的数据压入栈中。如果最后入栈序列数据都进了辅助栈，而最终的辅助栈为空，说明可以按照出栈序列的顺序出栈。

#### 面试题32_1：不分行从上到下打印二叉树

层次遍历，广度优先，考虑使用队列。

> 取栈顶元素用top()；取队首元素用front()。

#### 面试题32_2：分行从上到下打印二叉树

- 解法一：

分行需要知道每行结点数量，这里可以用两个临时变量，一个记录当前层次结点总数n，另一个用来记录push进来的下一层结点数m，当前层次结点打印完后，将下一层结点数m赋值给n，m重置为0。

- 解法二：

也可以只用一个变量，初始非空树只放了根节点在队列，此时这一层结点数为1，当打印1个并pop出一个结点后，队列里面存的应该都是根节点下一层全部n个结点，因此再打印n个数据后换行。